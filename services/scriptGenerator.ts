import { DeploymentConfig } from '../types';
import yaml from 'js-yaml';

/**
 * Cleans the Compose file by removing CasaOS specific metadata and applying UI overrides (Env Vars).
 */
export const cleanComposeContent = (rawYaml: string, config: DeploymentConfig): { yaml: string, volumes: string[] } => {
  try {
    const doc = yaml.load(rawYaml) as any;
    const extractedVolumes: string[] = [];

    if (!doc || !doc.services) return { yaml: rawYaml, volumes: [] };

    // Remove top-level x-casaos
    if (doc['x-casaos']) delete doc['x-casaos'];

    // Process services
    for (const serviceName in doc.services) {
      const service = doc.services[serviceName];

      // Remove service-level x-casaos
      if (service['x-casaos']) delete service['x-casaos'];

      // Apply Environment Variable Overrides from UI
      if (config.envVars && Object.keys(config.envVars).length > 0) {
        // We prefer object syntax for cleanliness in output
        if (Array.isArray(service.environment)) {
            // Convert array to object to merge
            const envObj: Record<string, string> = {};
            service.environment.forEach((e: string) => {
                const parts = e.split('=');
                const k = parts[0];
                const v = parts.slice(1).join('=');
                if (k) envObj[k] = v;
            });
            service.environment = { ...envObj, ...config.envVars };
        } else {
            service.environment = { ...(service.environment || {}), ...config.envVars };
        }
      }

      // Collect and Clean Volumes
      if (service.volumes && Array.isArray(service.volumes)) {
        service.volumes = service.volumes.map((vol: string) => {
           // CasaOS legacy path cleanup
           let finalVol = vol.replace(/^\/DATA\/AppData\/[^/]+\//, './data/').replace(/^\/DATA\/AppData\/[^/]+/, './data');
           
           // Extract host path to create directories later inside the LXC
           let hostPath = '';
           if (typeof finalVol === 'string') {
               hostPath = finalVol.split(':')[0];
           } else if (typeof finalVol === 'object' && (finalVol as any).source) {
               hostPath = (finalVol as any).source;
           }

           // We only care about creating paths that look like paths (start with / or .)
           // Named volumes (just "db_data") are handled by docker automatically
           if (hostPath && (hostPath.startsWith('/') || hostPath.startsWith('./'))) {
               extractedVolumes.push(hostPath);
           }
           
           return finalVol;
        });
      }
      
      // Ensure Ports are strings
      if (service.ports && Array.isArray(service.ports)) {
          service.ports = service.ports.map((p: any) => p.toString());
      }
    }

    return { 
        yaml: yaml.dump(doc, { lineWidth: -1, noRefs: true, quotingType: '"' }),
        volumes: [...new Set(extractedVolumes)] // Deduplicate
    };
  } catch (e) {
    console.error("Error parsing YAML:", e);
    return { yaml: rawYaml, volumes: [] };
  }
};

/**
 * Generates a Bash script to be run on the Proxmox HOST.
 */
export const generateProxmoxScript = (config: DeploymentConfig): string => {
  const { yaml: cleanedYaml, volumes } = cleanComposeContent(config.composeContent, config);
  
  // Escape for heredoc
  const safeYaml = cleanedYaml.replace(/\\/g, '\\\\').replace(/\$/g, '\\$').replace(/`/g, '\\`');

  // Network Configuration Logic
  let netConfig = `name=eth0,bridge=${config.bridge},ip=dhcp`;
  if (!config.useDhcp && config.staticIp) {
      netConfig = `name=eth0,bridge=${config.bridge},ip=${config.staticIp}`;
      if (config.gateway) {
          netConfig += `,gw=${config.gateway}`;
      }
  }

  // Volume Creation Commands to run INSIDE the container
  // Logic: if it starts with ./ it is relative to /opt/APP_ID/
  const volumeCreationCmds = volumes.map(v => {
      if (v.startsWith('./')) {
          return `mkdir -p "/opt/${config.appId}/${v.substring(2)}"`;
      }
      return `mkdir -p "${v}"`;
  }).join('\n');

  return `#!/usr/bin/env bash

# ==============================================================================
# App Converter - Automated Proxmox LXC Installer
# App: ${config.appName}
# Target: Docker in Unprivileged LXC
# Generated by: App Converter
# ==============================================================================

set -e

# --- Configuration Variables ---
APP_ID="${config.appId}"
HOSTNAME="${config.appId}"
PASSWORD="${config.password || 'password'}"
DISK_SIZE="${config.diskSize}"
CPU_CORES="${config.cpuCores}"
RAM_SIZE="${config.ramSize}"
STORAGE="${config.storagePool}"
TEMPLATE_SEARCH="debian-12-standard"
CT_ID_START=105

# --- Styling & Helpers ---
YW='\\e[1;33m'
GN='\\e[0;32m'
RD='\\e[0;31m'
CL='\\e[0m'

function msg_info() { echo -e "\${YW}[INFO] \${1}\${CL}"; }
function msg_ok() { echo -e "\${GN}[OK] \${1}\${CL}"; }
function msg_err() { echo -e "\${RD}[ERROR] \${1}\${CL}"; }

# --- 1. Find Next Free CTID ---
function get_next_id() {
    local next_id=\$CT_ID_START
    while pct status \$next_id &>/dev/null; do
        next_id=\$((next_id + 1))
    done
    echo \$next_id
}
CTID=\$(get_next_id)

msg_info "Starting Automated Installation for ${config.appName}..."
msg_info "Container ID: \${CTID}"
msg_info "Hostname:     \${HOSTNAME}"

# --- 2. Template Management ---
msg_info "Checking for Debian 12 Template..."
TEMPLATE_VOL=$(pveam available -section system | grep "\$TEMPLATE_SEARCH" | head -n 1 | awk '{print $2}')
if [ -z "$TEMPLATE_VOL" ]; then
    msg_err "Template \$TEMPLATE_SEARCH not found. Please run 'pveam update'."
    exit 1
fi

if ! pveam list local | grep -q "\$TEMPLATE_VOL"; then
    msg_info "Downloading template \$TEMPLATE_VOL..."
    pveam download local \$TEMPLATE_VOL
fi
TEMPLATE="local:vztmpl/\$TEMPLATE_VOL"

# --- 3. Create Container (Automated Wizard) ---
msg_info "Creating LXC Container..."
pct create \$CTID \$TEMPLATE \\
    --arch amd64 \\
    --hostname \$HOSTNAME \\
    --cores \$CPU_CORES \\
    --memory \$RAM_SIZE \\
    --swap 512 \\
    --storage \$STORAGE \\
    --password "\$PASSWORD" \\
    --rootfs volume=\$STORAGE:\${DISK_SIZE} \\
    --net0 ${netConfig} \\
    --unprivileged 1 \\
    --features nesting=1,keyctl=1 \\
    --onboot 1

msg_ok "LXC Container created successfully."

# --- 4. Start & Wait for Network ---
msg_info "Starting container..."
pct start \$CTID
msg_info "Waiting for network connectivity..."
lxc-attach -n \$CTID -- bash -c "for i in {1..50}; do ping -c1 8.8.8.8 &>/dev/null && break; sleep 1; done"

# --- 5. Install Dependencies & Docker (Inside Container) ---
msg_info "Installing Docker & Environment inside container..."

lxc-attach -n \$CTID -- bash -c "cat <<EOF > /tmp/install_internal.sh
#!/bin/bash
set -e

echo 'Updating system...'
apt-get update -qq && apt-get upgrade -y -qq
apt-get install -y -qq curl git ca-certificates gnupg lsb-release

echo 'Installing Docker...'
if ! command -v docker &> /dev/null; then
    curl -fsSL https://get.docker.com -o get-docker.sh
    sh get-docker.sh >/dev/null 2>&1
    rm get-docker.sh
fi

echo 'Pre-creating volume directories...'
mkdir -p /opt/\$APP_ID
cd /opt/\$APP_ID
${volumeCreationCmds}

echo 'Writing docker-compose.yml...'
cat <<YML > docker-compose.yml
${safeYaml}
YML

echo 'Starting Application...'
docker compose pull -q
docker compose up -d

echo 'Cleaning up...'
apt-get autoremove -y -qq
apt-get autoclean -y -qq
EOF
"

# Execute the internal script
lxc-attach -n \$CTID -- bash /tmp/install_internal.sh

# --- 6. Final Status ---
IP=\$(pct exec \$CTID -- ip a s dev eth0 | awk '/inet / {print \$2}' | cut -d/ -f1)

msg_ok "Installation Complete!"
echo -e "\${GN}--------------------------------------------------\${CL}"
echo -e " Application: ${config.appName}"
echo -e " IP Address:  \${IP}"
echo -e " Host Port:   ${config.hostPort}"
echo -e " URL:         http://\${IP}:${config.hostPort}"
echo -e "\${GN}--------------------------------------------------\${CL}"
`;
};

/**
 * Generates a Stack file for Dockge or Portainer.
 */
export const generateStackFile = (config: DeploymentConfig): string => {
  return cleanComposeContent(config.composeContent, config).yaml;
};